(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{462:function(n,e,t){n.exports=t.p+"assets/img/clijiegou.63efaec4.png"},463:function(n,e,t){n.exports=t.p+"assets/img/animate.d209d500.png"},550:function(n,e,t){"use strict";t.r(e);var a=t(14),s=Object(a.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"vue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[n._v("#")]),n._v(" Vue")]),n._v(" "),e("h2",{attrs:{id:"脚手架文件结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#脚手架文件结构"}},[n._v("#")]),n._v(" 脚手架文件结构")]),n._v(" "),e("img",{attrs:{src:t(462)}}),n._v(" "),e("h2",{attrs:{id:"关于不同版本的vue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于不同版本的vue"}},[n._v("#")]),n._v(" 关于不同版本的Vue")]),n._v(" "),e("ul",[e("li",[n._v("vue.js与vue.runtime.xxx.js的区别：\n（1）vue.js是完整版的Vue，包含：核心功能+模板解析器\n（2）vue.runtime.xxx.js是运行版的Vue，只包含：核心功能，没有模板解析器")]),n._v(" "),e("li",[n._v("因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用\nrender函数接收到的createElement函数去指定具体内容")])]),n._v(" "),e("h2",{attrs:{id:"vue-config-js配置文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-config-js配置文件"}},[n._v("#")]),n._v(" vue.config.js配置文件")]),n._v(" "),e("blockquote",[e("p",[n._v("使用vue inspect > output.js 可以查看到Vue脚手架的默认配置")])]),n._v(" "),e("blockquote",[e("p",[n._v("使用vue.config.js可以对脚手架进行个性化定制，详细见：https://cli.vuejs.org/zh")])]),n._v(" "),e("h2",{attrs:{id:"ref属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ref属性"}},[n._v("#")]),n._v(" ref属性")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('1、被用来给元素或子组件注册引用信息（id的替代者）\n2、应用在html标签上获取的是真实dom元素，应用在组件标签上是组件实例对象（vc）\n3、使用方式\n            打标识：<h5 ref="xxx">......</h5> 或 <school ref="xxx"/>\n            获取：this.$refs.xxx\n')])])]),e("h2",{attrs:{id:"配置项props"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#配置项props"}},[n._v("#")]),n._v(" 配置项props")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("    功能：让组件接收外部传过来的数据\n        （1）传递数据：\n                    <food foodName=\"xxx\"/>\n        （2）接收数据：\n                    第一种方式（只接收）：\n                        props: ['foodName']\n\n                    第二种方式（限制类型）：\n                        props: {\n                            foodName: String\n                        }\n\n                    第三种方式（限制类型、限制必要性、指定默认值）：\n                        props: {\n                            foodName: {\n                                type: String,\n                                required: true,\n                                default: '苹果'\n                            }\n                        }\n\n    备注：props是只读的，Vue底层会监测对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，可以复制props的内容到data中，然后修改data中的数据\n")])])]),e("h2",{attrs:{id:"mixin-混入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mixin-混入"}},[n._v("#")]),n._v(" mixin（混入）")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("    功能：可以把多个组件共用的配置提取成一个混入对象\n    使用方式：\n            第一步定义混合：\n                            {\n                                data() {...},\n                                methods: {...},\n                                ...\n                            }\n            第二步使用混入：\n                                使用前需要先引入  import {xxx,xxx} from ''\n                            （1）全局混入：Vue.mixin(xxx)\n                            （2）局部混入：mixins: [xxx]\n")])])]),e("h2",{attrs:{id:"插件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#插件"}},[n._v("#")]),n._v(" 插件")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("    功能：用于增强Vue\n    本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据\n    定义插件：\n            {\n                install(Vue) {\n                    // 全局过滤器\n                    Vue.filter('mySlice', function(v){\n                        return v.slice(0,5)\n                    })\n                    //  全局指令\n                    Vue.directive('pink', {\n                        bind(element, binding) {\n                            element.value = binding.value\n                        },\n                        inserted(element) {\n                            element.style.color = 'pink'\n                            element.style.backgroundColor='white'\n                        },\n                        update(element, binding) {\n                            element.value = binding.value\n                        }\n                    })\n                    //  定义混入\n                    Vue.mixin({\n                        data() {\n                            return {\n                                x: 100,\n                                y: 99\n                            }\n                        },\n                    })\n                    // 给Vue原型添加一个方法\n                    Vue.prototype.hello = ()=>{alert('你好，使用者')}\n                }\n            }\n    使用插件：先引入，然后Vue.use(xxx)\n")])])]),e("h2",{attrs:{id:"scoped样式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#scoped样式"}},[n._v("#")]),n._v(" scoped样式")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("    作用：让样式在局部生效，防止冲突\n    写法：<style scoped>\n")])])]),e("h2",{attrs:{id:"自定义事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自定义事件"}},[n._v("#")]),n._v(" 自定义事件")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("    1、一种组件间通信的方式，适用于：子组件 ===> 父组件\n    2、使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）\n    3、绑定自定义事件：\n        （1）第一种方式，在父组件中：<anime :getAnimeName=\"getAnimeName\"/>\n        （2）第二种方式，在父组件中：\n                                        <anime ref=\"anime\"/>\n                                        ......\n                                        mounted() {\n                                            this.$refs.anime.$on('getAnimeName', this.getAnimeName)\n                                        }\n        （3）若想让自定义事件只能触发一次，可以使用once修饰符或者$once()方法\n    4、触发自定义事件：this.$emit('事件名', 数据) 不需要，数据也可以不写\n    5、解绑自定义事件：this.$off('事件名')  this.$off(['事件名', '事件名']) this.$off() --解绑所有事件\n    6、组件上也可以绑定原生自定义事件   需要使用native修饰符    @click.native\n    7、注意：\n                通过this.$ref.xxx.$on(‘事件名’, 回调函数)绑定自定义事件时，回调要么配置在methods中要么使用箭头函数，否则this指向会出现问题\n")])])]),e("h2",{attrs:{id:"全局事件总线-globaleventbus"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#全局事件总线-globaleventbus"}},[n._v("#")]),n._v(" 全局事件总线（GlobalEventBus）")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("        1、一种组件间通信的方式，适用于任意组件间通信\n        2、安装全局事件总线：\n                new Vue({\n                    ......\n                    beforeCreate() {\n                        Vue.prototype.$bus = this   // 安装全局事件总线，$bus就是当前应用的vm\n                    },\n                    ......\n                })\n        3、使用全局事件总线：\n                （1）接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身\n                            methods() {\n                                demo(data) {\n                                    ......\n                                }\n                            }\n                            mounted() {\n                                this.$bus.$on('xxx', this.demo)\n                            }\n                    （2）提供数据：this.$bus.$emit('xxx', 数据)\n        4、最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件\n")])])]),e("h2",{attrs:{id:"消息订阅与发布-pubsub"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#消息订阅与发布-pubsub"}},[n._v("#")]),n._v(" 消息订阅与发布（pubsub）")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("    1、一种组件间通信的方式，适用于任意组件间通信\n    2、使用步骤：\n            （1）安装pubsub：npm install pubsub-js\n            （2）import pubsub from 'pubsub-js'\n            （3）接收数据：A组件想接收数据，则在A中订阅消息，订阅的回调留在A组件自身\n                                    mounted() {\n                                        // 每一个消息订阅都会有唯一的ID\n                                        this.pubId = pubsub.subscribe('demo', (msgName, data) =>{\n                                            console.log(msgName, data);\n                                            this.receiveData = data;\n                                        })\n                                    },\n                                    beforeDestroy() {\n                                        // 根据ID取消订阅\n                                        pubsub.unscribe(this.pubId)\n                                    }\n            （4）提供数据：\n                                    methods: {\n                                        sendName() {\n                                            //          订阅的消息名，数据\n                                            pubsub.publish('demo', this.studentName)\n                                        }\n                                    }\n            （5）取消订阅：\n                                    beforeDestroy() {\n                                        // 根据ID取消订阅\n                                        pubsub.unscribe(this.pubId)\n                                    }\n    ### 也可以使用其他的库\n")])])]),e("h2",{attrs:{id:"nexttick"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nexttick"}},[n._v("#")]),n._v(" nextTick")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("        1、语法：this.$nextTick(回调函数)\n        2、作用：在下一次DOM更新结束后执行其回调函数\n        3、什么时候用：当数据改变后，要基于更新后的新DOM进行某些操作时，要在nextTick指定的回调函数中执行\n")])])]),e("h2",{attrs:{id:"vue封装的过度与动画"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue封装的过度与动画"}},[n._v("#")]),n._v(" Vue封装的过度与动画")]),n._v(" "),e("img",{attrs:{src:t(463)}}),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('    1、作用：在插入、更新或移除DOM元素时，在合适的时候给元素添加样式类名\n    2、图示：👆\n    3、写法：\n        （1）准备好样式：\n                元素进入的样式：\n                    1、v-enter：进入的起点\n                    2、v-enter-active：进入过程中\n                    3、v-enter-to：进入的终点\n                元素离开的样式：\n                    1、v-leave：离开的起点\n                    2、v-leave-active：离开过程中\n                    3、v-leave-to：离开的终点\n        （2）使用&lt;transition>包裹要过度的元素，并配置name属性：\n                        &lt;transition name="naihe">\n                            &lt;h1 v-show="isShow">Naihe真帅<h1/>\n        （3）备注：若有多个元素需要过度，则需要使用：&lt;transition-group>包裹，且需要给每个元素设置key值\n\n    4、也可以使用外部样式\n            先安装：npm install animate.css\n            网址：https://animate.style/\n            使用：\n                    <transition\n                        name="animate__animated animate__bounce"\n                        enter-active-class="animate__swing"\n                        leave-active-class="animate__backOutUp"\n                        appear>\n')])])]),e("h2",{attrs:{id:"vue脚手架配置代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue脚手架配置代理"}},[n._v("#")]),n._v(" Vue脚手架配置代理")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("    方法一、\n                在vue.config.js中添加如下配置\n                devServer: {\n                    proxy: 'http://localhost:8077'\n                }\n                说明：\n                    1、优点：配置简单，请求资源时直接发送给前端（8080）即可\n                    2、缺点：不能配置多个代理，不能灵活控制请求是否走代理\n                    3、工作方式：请求不存在资源时，请求会转发给服务器（优先匹配前端资源）\n    方法二、\n                编写vue.config.js配置具体代理规则\n                devServer: {\n                    proxy: {\n                        '/data': {\n                            target: 'http://localhost:8077',\n                            pathRewrite: {'^/data': ''},\n                            ws: true, // 用于支持websocket\n                            changeOrigin: true\n                        }\n                    }\n                }\n                说明：\n                    1、优点：可以配置多个代理，且可以灵活控制请求是否走代理\n                    2、缺点：配置略微繁琐，请求资源时必须加前缀\n")])])]),e("h2",{attrs:{id:"插槽"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#插槽"}},[n._v("#")]),n._v(" 插槽")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('1、作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于父组件 ===> 子组件\n2、分类：默认插槽、具名插槽、作用域插槽\n3、使用方式：\n        （1）默认插槽：\n                        父组件：\n                        <Chacao>\n                            <div>html结构</div>\n                        </Chacao>\n                        子组件：\n                        <template>\n                            <div>\n                                \x3c!-- 定义插槽 --\x3e\n                                <slot>这里可以写插槽默认内容</slot>\n                            </div>\n                        </template>\n        （2）具名插槽：\n                        父组件：\n                        <Chacao>\n                            <div slot="center">html结构</div>\n                            或者\n                            <template v-slot:center></template>\n                            注意：这种写法只适用于template\n                        </Chacao>\n                        子组件：\n                        <slot name="center"></slot>\n        （3）作用域插槽：\n                        理解：数据在组件自身，但根据数据生成的结构需要组件的使用者来决定\n                        具体编码：\n                            父组件：\n                            <Chacao>\n                                <div scope="data">html结构</div>\n                            </Chacao>\n                            子组件：\n                            <slot :phones="phones"></slot>\n                            data() {\n                                return {\n                                    phones: ["华为", "小米", "苹果"],\n                                }\n                            }\n')])])]),e("h2",{attrs:{id:"vuex"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[n._v("#")]),n._v(" Vuex")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("概念：在Vue中实现集中式状态（数据）管理的一个Vue插件，对Vue应用中多个组件的共享状态进行集中式管理，也是一种组件间通信的方式，且适用于任意\n            组件间通信\n何时使用？\n            多个组件需要共享数据时\n搭建Vuex环境\n    1、创建文件：src/store/index.js\n                // 该文件用于创建Vuex中最为核心的store\n\n                // 引入vue\n                import Vue from 'vue'\n                // 引入vuex\n                import Vuex from 'vuex'\n\n                Vue.use(Vuex)\n                // 准备actions用于响应组件中的动作\n                const actions = {}\n                // 准备mutations用于操作数据（state）\n                const mutations = {}\n                // 准备state用于存储数据\n                const state = {}\n\n                // 创建store\n                export default new Vuex.Store({\n                    actions,\n                    mutations,\n                    state\n                })\n    2、在main.js中创建vm时传入store配置项\n                import store from './store/index'\n                new Vue({\n                    render: h => h(App),\n                    store,\n                }).$mount('#app')\n")])])]),e("h2",{attrs:{id:"getters的使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#getters的使用"}},[n._v("#")]),n._v(" getters的使用")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("当state中的数据需要进行加工后再使用时，可以使用getters\nconst getters = {\n    bigNum(state) {\n        return state.sum * 10\n    }\n}\n\nexport default new Vuex.store({\n    ......,\n    getters\n})\n")])])]),e("h2",{attrs:{id:"四个map方法的使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四个map方法的使用"}},[n._v("#")]),n._v(" 四个map方法的使用")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("1、mapState方法：用于帮助我们映射state中的数据为计算属性\n    computed: {\n                        函数名   映射的属性名\n        ...mapState({name: 'name'}) / ...mapState(['name']) 这种写法state中必须要有name属性\n    }\n2、mapGetters方法：用于帮助我们映射getters中的数据为计算属性\n    computed: {\n        ...mapGetters({info: 'info'}) / ...mapState(['info']) 这种写法getters中必须要有info属性\n    }\n3、mapActions方法：用于帮助我们生成与actions对话的方法，即包含$store.dispatch(xxx)的函数，方法调用时需要传入相应的参数\n        @click(getName(value))\n4、mapMutations方法：用于帮助我们生成与mutations对话的方法，即包含$store.commit(xxx)的函数， 同上\n")])])]),e("h2",{attrs:{id:"模块化-命名引用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块化-命名引用"}},[n._v("#")]),n._v(" 模块化 + 命名引用")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("目的：让代码更好维护，让多种数据分类更加明确\nconst a = {\n    namespaced: true, //开启命名空间\n    state: {},\n    mutations: {},\n    actions: {},\n    getters: {}\n}\nconst b = {\n    namespaced: true, //开启命名空间\n    state: {},\n    mutations: {},\n    actions: {},\n    getters: {}\n}\nnew Vuex.store({\n    modules: {\n        a,\n        b\n    }\n})\n开启命名空间后，组件中读取state数据：\n    // 方式一：自己直接读取\n    this.$store.state.a.list\n    // 方式二：借助apState读取\n    ...mapState('b', ['sum', 'bigNum' ,'name'])\n开启命名空间后，组件中读取getters数据：\n    // 方式一：自己直接读取\n    this.$store.getters['a/name']\n    // 方式二：借助mapGetters读取\n    ...mapGetters('a', ['name'])\n开启命名空间后，组件中调用dispatch：\n    // 方式一：自己直接调用dispatch\n    this.$store.dispatch('b/addPerson', person)\n    // 方式二：借助mapActions\n    ...mapActions('b', {add: 'addPerson'})\n开启命名空间后，组件中调用commit：\n    // 方式一：自己直接调用commit\n    this.$store.commit('b/getName', name)\n    // 方式二：借助mapMutations\n    ...mapMutations('b', {getName: 'getName'})\n")])])]),e("h2",{attrs:{id:"路由"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路由"}},[n._v("#")]),n._v(" 路由")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("    vue-router：vue的一个插件库。专门用来实现SPA应用/单页面应用\n    对SPA理解：\n        1、单页面Web应用（single page web application， SPA）\n        2、整个应用只有一个完整的页面\n        3、单击页面中的导航链接不会刷新页面，只会做页面的局部更新\n        4、数据需要通过ajax请求获取\n    路由的理解：\n        1、一个路由就是一组映射关系（key-value），多个路由需要由路由器进行管理\n        2、key为路径，value可能是funcation或component\n    路由的分类：\n        1、后端路由：\n            1）理解：value是funcation，用于处理客户端提交的请求\n            2）工作过程：服务器收到一个请求时，根据路径找到匹配的函数来处理请求，返回响应数据\n        2、前端路由：\n            1）理解：value是component，用于展示页面内容\n            2）工作过程：当浏览器路径改变时，对应的组件就会显示\n    基本使用：\n    \t1、安装vue-router，npm install vue-router\n    \t2、应用插件：Vue.use(VueRouter) 需要先引入\n    \t3、编写router配置项\n                    // 该文件用于创建整个应用的路由器\n                    import VueRouter from 'vue-router'\n\n                    // 引入组件\n                    import Home from '../components/Home.vue'\n                    import Image from '../components/Image.vue'\n\n                    // 创建并暴露一个路由器\n                    export default new VueRouter({\n                        routes: [\n                            {\n                                path: '/home',\n                                component: Home\n                            },\n                            {\n                                path: '/image',\n                                component: Image\n                            }\n                        ]\n                    })\n        4、实现切换（active-class可配置高亮样式）\n                <router-link to=\"/home\"></router-link>\n        5、指定展示位置\n                <router-view></router-view>\n    注意：\n            1、一般pages文件夹存放路由组件\n                components文件夹存放一般组件\n            2、切换的路由会被销毁，需要的时候再挂载\n            3、每个组件都有自己的$route属性，里面存储着自己的路由信息\n            4、整个应用只有一个router，可以通过组件的$router属性获取\n    多级路由：\n        1、配置路由规则，使用children配置项\n                routes: [\n                    {\n                        path: '/home',\n                        component: Home\n                    },\n                    {\n                        path: '/image',\n                        component: Image,\n                        children: [\n                            {\n                                path: 'libai', // 此处一定不要写 /libai\n                                component: Lb\n                            },\n                            {\n                                path: 'juyoujing',\n                                component: Jyj\n                            },\n                            {\n                                path: 'shangguanwaner',\n                                component: Sgwr\n                            }\n                        ]\n                    }\n                ]\n        2、跳转：\n                <router-link to=\"/image/shangguanwaner\">要写完整路径</router-link>\n    query传参：\n        1、传递参数\n                1）字符串写法\n                <router-link :to=\"`/image/libai?hero=${heroName}`\"></router-link>\n                2）对象写法\n                <router-link :to=\"{\n                    path: '/image/shangguanwaner',\n                    query: {\n                    hero: 'ShangGuanWanEr'\n                    }\n                }\">\n        2、接收参数\n                $route.query.xxx\n    命名路由：\n        作用：简化路由跳转\n        使用：\n            ...\n            routes: [\n                {\n                    name: 'zhuye',\n                    path: '/home',\n                    component: Home\n                }\n            ]\n\n            <router-link :to=\"{name: 'zhuye'}\"></router-link>\n    路由的params参数：\n        配置路由，声明接收params参数\n            routes: [\n                {\n                    name: 'zhuye',\n                    path: '/home/:hero', // 使用占位符声明接收params参数\n                    component: Home\n                }\n            ]\n        传递参数\n            <router-link to=\"/home/参数\"></router-link>\n            或\n            <router-link :to=\"{\n                name: 'zhuye', // 使用params参数时，一定要使用name而不是path\n                params: {\n                    hero: 'xxx'\n                }\n            }\"></router-link>\n        接收参数\n            $route.params.hero\n    路由的props配置：\n        作用：让路由组件更方便收到参数\n                routes: [\n                    {\n                        name: 'waner',\n                        path: '/waner',\n                        component: Waner,\n                        // 第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Waner组件\n                            props: {hero: '婉儿'}\n                        // 第二种写法：props值为布尔值，为true，把路由收到的所有params参数通过props传给Waner组件\n                            props: true\n                        // 第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Waner组件\n                            props($rourte) {\n                                return {\n                                    hero: $route.query.hero\n                                }\n                            }\n                        // 以上的方式，在需要收到参数的组件中需要使用props来接收\n                            props: ['hero']\n                    }\n                ]\n    <router-link>的replace属性：\n        作用：控制路由跳转时操作浏览器历史记录的模式\n            浏览器的历史记录有两种写入模式：push和replace，push是追加历史记录，replace是替换当前记录，默认为push\n        如何开启replace模式：<router-link replace></router-link>\n    编程式路由导航：\n        作用：不借助<router-link>实现路由跳转，让路由跳转更加灵活\n        编码：\n                this.$router.push({  // replace\n                    name: 'detail',\n                    params: {\n                        id: l.id,\n                        title: l.title\n                    }\n                })\n    缓存路由组件：\n        作用：让不展示的路由组件保持挂载，不被销毁\n        编码：\n                                :include=\"['组件名', '组件名']\"\n                <keep-alive include=\"组件名\"> 如果不写include，默认保持view里的所有组件\n                    <router-view></router-view>\n                </keep-alive>\n    两个新的生命周期钩子：\n        作用：路由组件独有的两个钩子，用于捕获路由组件的激活状态\n            ：\n                activated：路由组件被激活时触发\n                deactivated：路由组件失活时触发\n")])])]),e("h2",{attrs:{id:"路由守卫"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路由守卫"}},[n._v("#")]),n._v(" 路由守卫")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("    1、作用：对路由权限进行控制\n    2、分类：全局守卫、独享守卫、组件内守卫\n    3、全局守卫：\n                // 全局前置路由守卫---初始化的时候被调用，每次路由切换之前调用\n                router.beforeEach((to, from, next) => {\n                    console.log(to, from);\n                    console.log('当前访问用户：' + sessionStorage.getItem('username'));\n                    if(to.meta.isAuth) {\n                        if(sessionStorage.getItem('username') === 'Naihe') {\n                            next();\n                        }else {\n                            console.log('%c 身份认证失败', 'color: pink;');\n                        }\n                    }else {\n                        next();\n                    }\n                })\n\n                // 全局后置路由守卫---初始化的时候被调用，每次路由切换后调用\n                router.afterEach((to, from) => {\n                    console.log(from);\n                    document.title = to.meta.title || '灵云系统'\n                })\n    4、独享守卫：\n                独享守卫只有一个进入前\n                beforeEnter: (to, from, next) => {\n                    console.log(sessionStorage.getItem('username') + `访问了${to.meta.title}`);\n                    if(to.meta.isAuth) {\n                        if(sessionStorage.getItem('username') === 'Naihe') {\n                            console.log(from);\n                            next();\n                            console.log('结果：%c 通过', 'color: green;');\n                        }else {\n                            console.log('结果：%c 身份认证失败', 'color: red;');\n                        }\n                    }\n                }\n    5、组件内守卫：\n                beforeRouteEnter (to, from, next) {// 通过路由规则，进入该组件时被调用\n                    console.log(to, from);\n                    next()\n                },\n                beforeRouteLeave (to, from, next) {// 通过路由规则，离开该组件时被调用\n                    console.log(to, from);\n                    next()\n                }\n")])])]),e("h2",{attrs:{id:"路由器的两种工作模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路由器的两种工作模式"}},[n._v("#")]),n._v(" 路由器的两种工作模式")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("    hash、history\n    1、对于一个url来说，什么是hash值？\n                #及其后面的内容就是hash值\n    2、hash值不会包含在HTTP请求中，即：hash值不会带给服务器\n    3、hash模式：\n            1）地址中永远带着#号，不美观\n            2）若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法\n            3）兼容性较好\n    4、history模式：\n            1）地址干净，美观\n            2）兼容性和hash模式相比较差\n            3）应用部署上线时需要后端人员支持，解决刷新页面时服务端404问题\n                    也可以使用第三方库：\n                        npm i connect-history-api-fallback\n                        const history = require('connect-history-api-fallback')\n                        xxx.use(history())\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);